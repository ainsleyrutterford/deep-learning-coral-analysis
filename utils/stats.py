# -*- coding: utf-8 -*-
"""
Created on Mon Sep 21 10:33:09 2020

@author: Leonardo Bertini

This script is used for the statistical analysis of coral linear extension rates produced by an AI-based and a Human-based approach

AI-dataset is generated by https://github.com/ainsleyrutterford/deep-learning-coral-analysis/blob/master/utils/calcification.py

Human based dataset file is given as 'results_human.csv'
"""

import pandas as pd
from scipy import stats
from scipy.stats import pearsonr
import matplotlib.pyplot as plt
import seaborn as sns
import numpy 
from sklearn.linear_model import LinearRegression

## loading raw datasets
#Human-based dataset
Human_dataset = pd.read_csv("csv/results_human.csv")
  
#AI-based dataset                  
AI_dataset = pd.read_csv("csv/raw_data.csv")
AI_dataset["Linear_ext"]= AI_dataset["Voxel_size"]*AI_dataset["Length_in_pixels"] 
#calculate liner extension by multiplying length by voxel size column

#Fixing Computer dataset and appending new columns to dataframe
newlist_slice=[]
newlist_ROI=[]
for x in AI_dataset['Rectangle']:
    
    if x == 1 or  x == 2 or x == 3:
        newlist_slice.append('RS0030')
        newlist_ROI.append(x) 
        
    if x == 4 or x == 5 or x == 6:
        newlist_slice.append('RS0116')
        if x == 4:
           newlist_ROI.append(2) 
        if x == 5:
           newlist_ROI.append(1) #these were swapped 
        if x == 6:
           newlist_ROI.append(3) 
           
    if x == 7 or x == 8 or x == 9:
       newlist_slice.append('RS0128')
       if x == 7:
           newlist_ROI.append(1)
       if x == 8:
           newlist_ROI.append(2) 
       if x == 9:
           newlist_ROI.append(3)

#Adding columns to Human dataset
AI_dataset['Slice'] = newlist_slice
AI_dataset['ROI'] = newlist_ROI


#subset into Linear extention ONLY datasets
linear_human= Human_dataset[['Slice','ROI','Linear_ext']]
linear_human['Origin']= 'Human'
linear_pc=AI_dataset[['Slice','ROI','Linear_ext']]
linear_pc['Origin']= 'AI'

#Getting single dataset merging Human and AI data
newDF=pd.concat([linear_human,linear_pc]) #concat by column

#creating new categorical variable to do ROI breakdown across slices
newlist=[]
for x,y in zip(newDF['Slice'],newDF['ROI']):
    newlist.append(x + "_" + str(y))
newDF['Unified']=newlist
    
#PLOTS
#Comparisson plot between human and AI with ROI breakdown
figure1 = plt.figure()
sns.boxplot(y='Linear_ext', x='Unified',
                 data=newDF, 
                 palette="colorblind",
                 hue='Origin')
plt.ylabel("Linear extension rates (mm yr$^{-1}$)")
plt.xlabel("Slice_ROI breakdown")
plt.legend(title='Method')
plt.xticks(rotation=90)
figure1.savefig('figure_S4_1.svg', format='svg', dpi=600)



#Comparisson plot between human and AI without ROI breakdown
figure2=plt.figure()
sns.boxplot(y='Linear_ext', x='Slice',
                 data=newDF, 
                 palette="colorblind",
                 hue='Origin')
plt.ylabel("Linear extension rates (mm$^{-1}$)")
plt.xlabel("Slice")
plt.legend(title='Method')
figure2.savefig('figure_S4_2.svg', format='svg', dpi=600)



#Overal data for tables
newDF.groupby(["Unified","Origin"])["Linear_ext"].mean()


#table 1 data
AI_dataset.groupby([ "Slice"])["Linear_ext"].mean()
AI_dataset.groupby([ "Slice"])["Linear_ext"].sem()

Human_dataset.groupby([ "Slice"])["Linear_ext"].mean()
Human_dataset.groupby([ "Slice"])["Linear_ext"].sem()


#DATA FOR PAIRED T-test - Results section and table S1 data
a1=Human_dataset.groupby([ "Slice", "ROI"])["Linear_ext"].mean()
a2=Human_dataset.groupby([ "Slice", "ROI"])["Linear_ext"].sem()
b1=AI_dataset.groupby([ "Slice", "ROI"])["Linear_ext"].mean()
b2=AI_dataset.groupby([ "Slice", "ROI"])["Linear_ext"].sem()
c=stats.ttest_rel(a1.dropna(),b1.dropna())


# Create linear regression object
regr = LinearRegression()

#reshaping values from pandas objects
X = a1.values.reshape(-1,1)
Y = b1.values.reshape(-1,1)
# Train the model 
regr.fit(X,Y)

x_pred = numpy.asarray([2, 3, 4, 5, 8]).reshape(-1,1) #random values to use
y_pred = regr.predict(x_pred) # Make predictions using the random array

#Figure plot of linear relationship
figure3= plt.figure()
plt.plot(b1,a1,'ro')
plt.plot([1,2,3,4,5,6,7,8],[1,2,3,4,5,6,7,8],'b--')
#Pearsons correlation coefficient 
Correl=pearsonr(b1,a1)
plt.xlabel("AI-based \n Mean linear extension rates (mm yr$^{-1}$)")
plt.ylabel("Human-based \n Mean linear extension rates (mm yr$^{-1}$)")
plt.plot(y_pred, x_pred,'red')
plt.text(6.5,1, ("R$^{2}$ = " + str(round(Correl[0]**2,3)))) #note R**2
plt.legend(['mean linear extension data','x = y', 'Regression fit'])
figure3.savefig('figure_S4_3.svg', format='svg', dpi=600)


# ====OPTIONAL ===== #

# #Comparing ROIs individually and writing a .csv with results
# ROIlist=['RS0030_1','RS0030_2','RS0030_3', 'RS0116_1', 'RS0116_2', 'RS0116_3', 'RS0128_1', 'RS0128_2', 'RS0128_3']
# results=[]
# with open('stat_results_ROI_individual_comparisson.csv', mode="w") as f:
#     writer = csv.writer(f, lineterminator = '\n')
#     writer.writerow(["Comparing between each ROI"])
#     writer.writerow(["ROI", "Tstatistic", "p-value"])
#     for i in ROIlist:
#         RS = newDF.loc[newDF['Unified'] == i]
#         RS_human = RS.loc[RS['Origin'] == 'Human']
#         RS_ai = RS.loc[RS['Origin'] == 'AI']
#         a = RS_human["Linear_ext"]
#         b = RS_ai["Linear_ext"]
#         out = stats.ttest_ind(a.dropna(),b.dropna())
#         row = [i, out[0] , out[1]]
#         print(row)
#         writer.writerow(row)
   
#     #Comparing between each slice    
#     writer.writerow([["Comparing means between slices"]])
    
#     for j in ['RS0030','RS0116','RS0128'] :
#         RS = newDF.loc[newDF['Slice'] == j]
#         RS_human = RS.loc[RS['Origin'] == 'Human']
#         RS_ai = RS.loc[RS['Origin'] == 'AI']
#         a = RS_human["Linear_ext"]
#         b = RS_ai["Linear_ext"]
#         out = stats.ttest_ind(a.dropna(),b.dropna())
#         row = [j, out[0] , out[1]]
#         print(row)
#         writer.writerow(row)
# f.close()                                                                                                         
